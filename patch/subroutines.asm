incsrc "prelude.asm"

; This file is in a bit of a weird situation.
; Every sprite needs to have the locations for the shared subroutines.
; However, multiply-assembling the shared subroutines is unacceptable:
; if they freecode every time a sprite is assembled,
; they will take up *even more* freespace than sprites would have taken
; without using the shared subroutines. Typically, the solution to this
; kind of thing is to use a proper object file format,
; but that's not really viable for SMW.
; Additionally, Asar got rid of xkas's export features (thanks),
; so we can't export our subroutines either.
; So what's done here is to have everything this file prints dropped into
; subroutine_ptrs.asm by the tool, and have the prelude include that.

; A note about this method is that !ssr_DoWhatever is /not/ defined correctly
; while this file is being assembled, so you can't use them in here;
; if you're writing an ssr that calls another one,
; call it with "jsl DoWhatever" instead.

macro smw_ssr(name, offset)
	; We can't print this in one go or Asar tries to dereference it.
	print "!","ssr_<name> = $", hex(<offset>)
	<name> = <offset>
endmacro

macro dys_ssr(name)
	print "!","ssr_<name> = $", pc
<name>:
endmacro

print "; This file is automatically generated, and should not be modified."
print "; See subroutines.asm for details."

%smw_ssr(FinishOamWrite, $01b7b3!F)
%smw_ssr(FindFreeSlot, $02a9e4!F)
%smw_ssr(NewRand, $01acf9!F)
%smw_ssr(Move, $01802a!F)
%smw_ssr(TranslateX, $018022!F)
%smw_ssr(TranslateY, $01801a!F)
%smw_ssr(CollidePlayer, $01a7dc!F)
%smw_ssr(CollideSpr, $018032!F)
%smw_ssr(CollideSprPlayer, $01803a!F)
%smw_ssr(CollideLevel, $019138!F)
%smw_ssr(HurtPlayer, $00f5b7!F)
%smw_ssr(ExecutePtr, $0086df!F)
%smw_ssr(Nothing, $00fade!F)

%dys_freecode()
START:
%dys_ssr(InitTables)
	phb : phk : plb
	jsl $07f722!F
	jsl $07f7a4!F
	plb : rtl

%dys_ssr(InitViaAct)
	phb : phk : plb
	jsl $07f722!F
	jsl $07f78b!F
	plb : rtl

%dys_ssr(GetDrawInfo)
	stz !spr_offscreenV,x
	stz !spr_offscreenH,x
	; check if we're on-screen horizontally
	lda !spr_posXL,x : cmp $1a
	lda !spr_posXH,x : sbc $1b
	beq .onScreenX
	inc !spr_offscreenH,x
.onScreenX
	lda !spr_posXH,x : xba : lda !spr_posXL,x
	rep #$20
	sec : sbc $1a
	; set carry if sprite pos outside (-$40..$140)
	clc : adc #$0040 : cmp #$0180
	sep #$20
	; a = carry
	rol : and #$01
	sta !spr_offscreen,x
	; if a != 0 (i.e. if we're offscreen), return
	bne .invalid

	lda !spr_props2,x : and #$20 : beq .noTopCheck
.topCheck
	lda !spr_posYL,x : clc : adc #$1c
	php
	cmp $1c : rol $00
	plp

	lda !spr_posYH,x : adc #$00 : lsr $00 : sbc $1d
	beq +
	lda #$02 : sta !spr_offscreenV,x
+
.noTopCheck
	lda !spr_posYL,x : clc : adc #$0c
	php
	cmp $1c : rol $00
	plp

	lda !spr_posYH,x : adc #$00
	lsr $00 : sbc $1d
	beq +
	inc !spr_offscreenV,x
+
	ldy !spr_oamIndex,x

	lda !spr_posXL,x
	sec : sbc $1a
	sta $00
	lda !spr_posYL,x
	sec : sbc $1c
	sta $01
	rtl

.invalid
;	plb
; This is the same stunt as the original GetDrawInfo,
; where it returns through the calling routine (rts),
; adapted to a jsl subroutine.
; a a A b b
; b b A
	rep #$10
	ply
	pla
	ply
	pha
	phy
	sep #$10
	rtl

ClsOam:
	db $e0,$e4,$e8,$ec,$f0,$f4,$f8,$fc
	db $5c,$58,$54,$50,$4c,$48,$44,$40
	db $3c,$38,$34,$30

macro __GET__DRAW__INLINE()
	stz !spr_offscreenV,x
	stz !spr_offscreenH,x
	lda !spr_posXL,x : cmp $1a
	lda !spr_posXH,x : sbc $1b
	beq +
	inc !spr_offscreenH,x
+	lda !spr_posXH,x : xba : lda !spr_posXL,x
	rep #$20
	sec : sbc $1a
	clc : adc #$0040 : cmp #$0180
	sep #$20
	rol : and #$01
	sta !spr_offscreen,x
	beq +
	rts
+
endmacro

%dys_ssr(Offscreen_A) ; PIXI compatibility addition
	and #$07 : asl : bra Offscreen
%dys_ssr(Offscreen_X1)
	lda #$02 : bra Offscreen
%dys_ssr(Offscreen_X2)
	lda #$04 : bra Offscreen
%dys_ssr(Offscreen_X3)
	lda #$06 : bra Offscreen
%dys_ssr(Offscreen_X4)
	lda #$08 : bra Offscreen
%dys_ssr(Offscreen_X5)
	lda #$0a : bra Offscreen
%dys_ssr(Offscreen_X6)
	lda #$0c : bra Offscreen
%dys_ssr(Offscreen_X7)
	lda #$0e : bra Offscreen
%dys_ssr(Offscreen_X0)
	lda #$00
Offscreen:
	sta $03
	jsl IsOffscreen : beq .ret
	phb : phk : plb
	
	; large levels don't differ in vertical/horizontal
	if !opt_largeLevels == 0
		lda $5b : lsr : bcs .vertical
	endif
	
.horizontal:
	; If y pos not in range (-$50 ... $1b0),
	; we're off screen
	if !opt_largeLevels == 0
		lda !spr_posYH,x : xba : lda !spr_posYL,x
		rep #$20
		clc : adc #$0050
		cmp #$0200
		sep #$20
		bpl .erase
	else
		lda !spr_posYH,x : xba : lda !spr_posYL,x
		rep #$20
		clc : adc #$0050
		sec : sbc $1c
		bmi .erase
		cmp #$0200
		bpl .erase
		sep #$20
	endif

	; don't erase us if "process offscreen" set
	; note that things can still go offscreen vertically.
	; This matches the original. I'm not sure why the original was
	; like that.
	lda !spr_props4,x : and #$04 : bne .end

	; Check left/right screen status every other frame
	; If we're on the right frame, we're offscreen if $1a + bound + xpos < 0
	; If we're on the left frame, we're offscreen if  $1a + bound - xpos < 0
	stz $00 : stz $01
	lda $13 : and #$01 : beq +
	ldy #$80 : sty $01
+	ora $03 : asl : tay
	lda !spr_posXH,x
	; Adjust the sign of our comparison based on left/right
	eor $01
	xba
	lda !spr_posXL,x
	rep #$20
	sta $00
	lda $1a : adc .horizBounds,y
	sec : sbc $00
	sep #$20
	bpl .end

.erase:
	if !opt_largeLevels
		; one of the branches from the other if can get here with rep #$20
		sep #$20
	endif
	stz !spr_status,x
	ldy !spr_loadStatIndex,x
	cpy #$ff : beq .end
	lda #$00
	if !dys_sprLoadStatuses < $2000
		sta !dys_sprLoadStatuses,y
	else
		phx
		tyx
		sta !dys_sprLoadStatuses,x
		plx
	endif
.end:
	plb
.ret:
	rtl

; large levels don't differ in vertical/horizontal
if !opt_largeLevels == 0
	.vertical:
		; in a horizontal level, things with the "process offscreen" bit
		; set can still go offscreen vertically.
		; in a vertical level, there is no similar rule for horizontal stuff,
		; so just let it live right away
		lda !spr_props4,x : and #$04 : beq .end
		
		; only process on even frames
		lda $13 : lsr : bcs .end
		
		; check if we are onscreen horizontally
		lda !spr_posXL,x : cmp #$00
		lda !spr_posXH,x : sbc #$00
		cmp #$02
		bcs .erase
		
		; check if we are onscreen vertically
		
		; get y-pos relative to screen
		lda !spr_posYH,x : xba : lda !spr_posYL,x
		rep #$20
		sec : sbc $1c
		
		bmi .aboveScreen
	.belowOrOnScreen:
		; if we have a positive screen pos, make sure we are not too far below
		cmp #$0140 : bcc .vEnd
		bcs .erase
	.aboveScreen:
		; if we have a negative screen pos, make sure we are not too far above
		cmp #$ffb0 : bcc .erase
	.vEnd:
		sep #$20
		plb
		rtl
endif

.horizBounds:
;      right   left
	dw $0130, $ffc0,   $01a0, $ffc0,   $01a0, $fff0,   $0160, $ff90
	dw $0130, $ffc0,   $01a0, $ff80,   $0040, $0160,   $0160, $ffb0
.vertBounds:
;      below  above
	dw $0140, $fec0

%dys_ssr(IsOffscreen)
	lda !spr_offscreenH,x : ora !spr_offscreenV,x
	rtl

%dys_ssr(HorizPos)
	ldy #$00
	lda $94 : sec : sbc !spr_posXL,x : sta $0f
	lda $95 : sbc !spr_posXH,x : bpl +
	iny
+	rtl

%dys_ssr(VertPos)
	ldy #$00
	lda $96 : sec : sbc !spr_posYL,x : sta $0f
	lda $97 : sbc !spr_posYH,x : bpl +
	iny
+	rtl

%dys_ssr(StompPoints)
	phy
	lda.w !WB|$1697 : inc.w !WB|$1697
	sec
	adc !spr_miscK,x
	tay
	cpy #$08 : bcs .noSound
	lda pointSounds,y : sta.w !WB|$1df9
.noSound
	; A = points or 8, whichever is smaller
	tya : cmp #$08 : bcc + : lda #$08 : +
	jsl $02ace5!F
	ply
	rtl

%dys_ssr(StarPoints)
	phy
	lda.w !WB|$18d2 : inc.w !WB|$18d2
	sec
	adc !spr_miscK,x
	tay
	cpy #$08 : bcs .noSound
	lda pointSounds,y : sta.w !WB|$1df9
.noSound
	; A = points or 8, whichever is smaller
	tya : cmp #$08 : bcc + : lda #$08 : +
	jsl $02ace5!F
	ply
	rtl

pointSounds:
	db $00,$13,$14,$15,$16,$17,$18,$19

; You may notice this subroutine is very similar to HorizPos.
; It exists because a lot of original game sprites set a similar routine
; as their whole init, and now Daiyousei sprites can too! wow.
%dys_ssr(FacePlayer)
	stz !spr_facing,x
	lda $94 : cmp !spr_posXL,x
	lda $95 : sbc !spr_posXH,x : bpl +
	inc !spr_facing,x
+	rtl

%dys_ssr(GenericGfx_16x16)
	sta $00
	sep #$20
	lda ($00),y
	sta $02
	jsr + : rtl
+	jsl GetDrawInfo
	if !opt_katysHack == 0
		lda $02 : sta !oam1_tile,y
	else
		lda $02 : clc : adc !spr_miscZ,x : sta !oam1_tile,y
	endif
	
	lda !spr_facing,x : lsr : ror : lsr : eor #$40
	ora !spr_tileProps,x
	ora $64
	sta !oam1_props,y
	lda $00 : sta !oam1_ofsX,y
	lda $01 : sta !oam1_ofsY,y

	ldy #$02
	lda #$00
	jsl FinishOamWrite
	lda !dys_lastOam : sta !spr_oamIndex,x
	rts

%dys_ssr(GenericGfx_32x16)
	sta $00
	tya
	asl
	tay
	lda ($00),y
	ldy !spr_facing,x : bne +
	xba
+	sta $02
	sep #$20
	jsr + : rtl
+	jsl GetDrawInfo
	lda !spr_facing,x : lsr : ror : lsr : eor #$40
	ora !spr_tileProps,x
	ora $64
	sta !oam1_props,y : sta !oam1_props+4,y
	lda $00 : sta !oam1_ofsX,y
	clc : adc #$10
	sta !oam1_ofsX+4,y
	lda $01 : sta !oam1_ofsY,y : sta !oam1_ofsY+4,y
	if !opt_katysHack == 0
		lda $02 : sta !oam1_tile,y
		lda $03 : sta !oam1_tile+4,y
	else
		lda $02 : clc : adc !spr_miscZ,x : sta !oam1_tile,y
		lda $03 : clc : adc !spr_miscZ,x : sta !oam1_tile+4,y
	endif
	ldy #$02
	lda #$01
	jsl FinishOamWrite
	lda !dys_lastOam : sta !spr_oamIndex,x
	rts

%dys_ssr(GenericGfx_16x32)
	sta $00
	tya
	asl
	tay
	lda ($00),y
	sta $02
	sep #$20
	jsr + : rtl
+	jsl GetDrawInfo
	lda !spr_facing,x : lsr : ror : lsr : eor #$40
	ora !spr_tileProps,x
	ora $64
	sta !oam1_props,y : sta !oam1_props+4,y
	lda $00 : sta !oam1_ofsX,y : sta !oam1_ofsX+4,y
	lda $01 : sta !oam1_ofsY+4,y
	sec : sbc #$10 : sta !oam1_ofsY,y
	if !opt_katysHack == 0
		lda $02 : sta !oam1_tile,y
		lda $03 : sta !oam1_tile+4,y
	else
		lda $02 : clc : adc !spr_miscZ,x : sta !oam1_tile,y
		lda $03 : clc : adc !spr_miscZ,x : sta !oam1_tile+4,y
	endif
	ldy #$02
	lda #$01
	jsl FinishOamWrite
	lda !dys_lastOam : sta !spr_oamIndex,x
	rts


%dys_ssr(GenericGfx_32x32)
	sta $00
	tya
	asl #2
	tay
	lda ($00),y
	sta $02
	iny #2
	lda ($00),y
	sta $04
	ldy !spr_facing,x : bne +
	xba : sta $04
	lda $02 : xba : sta $02
+	sep #$20
	jsr + : rtl
+	jsl GetDrawInfo
	lda !spr_facing,x : lsr : ror : lsr : eor #$40
	ora !spr_tileProps,x
	ora $64
	sta !oam1_props,y : sta !oam1_props+4,y
	sta !oam1_props+8,y : sta !oam1_props+12,y

	lda $00 : sta !oam1_ofsX,y : sta !oam1_ofsX+8,y
	clc : adc #$10
	sta !oam1_ofsX+4,y : sta !oam1_ofsX+12,y

	lda $01 : sta !oam1_ofsY+8,y : sta !oam1_ofsY+12,y
	sec : sbc #$10
	sta !oam1_ofsY,y : sta !oam1_ofsY+4,y

	if !opt_katysHack == 0
		lda $02 : sta !oam1_tile,y
		lda $03 : sta !oam1_tile+4,y
		lda $04 : sta !oam1_tile+8,y
		lda $05 : sta !oam1_tile+12,y
	else
		lda $02 : clc : adc !spr_miscZ,x : sta !oam1_tile,y
		lda $03 : clc : adc !spr_miscZ,x : sta !oam1_tile+4,y
		lda $04 : clc : adc !spr_miscZ,x : sta !oam1_tile+8,y
		lda $05 : clc : adc !spr_miscZ,x : sta !oam1_tile+12,y
	endif
	ldy #$02
	lda #$03
	jsl FinishOamWrite
	lda !dys_lastOam : sta !spr_oamIndex,x
	rts

%dys_ssr(GenericGfx_FTable16x16)
	sta $00
	tya : asl : tay
	lda ($00),y
	sta $02
	sep #$20

	jsr + : rtl
+	jsl GetDrawInfo

	phx
	
	if !opt_katysHack
		lda !spr_miscZ,x : pha
	endif

	; $00 = sprite pos y - screen pos y
	lda !spr_posYH,x : xba : lda !spr_posYL,x
	rep #$20
	sec : sbc $1c : sta $00
	sep #$20

	; $08 = sprite pos x - screen pos x
	lda !spr_posXH,x : xba : lda !spr_posXL,x
	rep #$20
	sec : sbc $1a : sta $08
	sep #$20

	; $04 = tile props
	lda !spr_facing,x : lsr : ror : lsr : eor #$40 : ora $64 : sta $04

	; $05-06 = direction as (0, -1)
	; $08 offset if facing right
	stz $0c
	stz $0d
	and #$40 : beq +
	rep #$21
	dec $0c
	lda $08 : adc ($02) : sec : sbc #$0010 : sta $08
	sep #$20
+	rep #$10
	; x = !oam1_tile & $ff00 | y & $00ff
	lda.b #!oam1_tile>>8 : xba : tya : tax
	; $0e = oam1_sizes + oam slot / 4
	lda.b #!oam1_sizes>>8 : sta $0f
	tya : lsr #2 : adc.b #!oam1_sizes : sta $0e

	ldy $02
.loop
; $00-01 - ofs y
; $02-03 - temp offset
; $04    - tile props
; $08-09 - ofs x
; $0c-0d - negation for x-offset
; $0e-0f - oam sizes ptr
	lda $0001,y : cmp #$ff : beq .end
	if !opt_katysHack == 0
		sta.b !oam1_tile,x
	else
		clc : adc $01,s
		sta.b !oam1_tile,x
	endif

	stz $03
	lda $0004,y : bpl + : dec $03 : + : sta $02
	rep #$21
	lda $00 : adc $02 : clc : adc #$0010 : cmp #$0100 : bcs .skipTile
	sep #$21
	sbc #$10 : sta.b !oam1_ofsY,x

	lda $0002,y : eor $04 : sta.b !oam1_props,x

	lda #$02 : sta ($0e)
	stz $03
	lda $0c : lsr
	lda $0003,y : bpl + : dec $03 : + : sta $02
	rep #$20
	lda $02 : eor $0c : adc $08
	sta $02
	and #$01ff
	cmp #$0100 : bcc +
	lda ($0e) : inc : sta ($0e)
	clc
+	tya : adc #$0004 : tay
	sep #$20
	lda $02 : sta.b !oam1_ofsX,x
	inx #4
	inc $0e
	bra .loop

.skipTile
	; carry is set here.
	tya : adc #$0003 : tay
	sep #$20
	bra .loop

.end
	sep #$30
	if !opt_katysHack
		pla
	endif
	lda $0e : sec : sbc.b #!oam1_sizes : asl #2 : sta !dys_lastOam
	plx
	sta !spr_oamIndex,x
	rts

%dys_ssr(GenericGfx_FTableMTS)
	sta $00
	tya
	asl
	tay
	lda ($00),y
	sta $0a
	sep #$20
	jsr + : rtl
+	jsl GetDrawInfo
	phx

	if !opt_katysHack
		lda #$00 : pha
		lda !spr_miscZ,x : pha
	endif
	
	lda $00 : sta $02
	lda !spr_facing,x : lsr : ror : lsr : eor #$40 : ora $64 : sta $05
	stz $0c
	and #$40 : beq +

	lda $00 : clc : adc ($0a)
	sec : sbc #$08 : sta $00
	sec : sbc #$08 : sta $02
	dec $0c

+	rep #$30
	tya : and #$00fc : lsr #2 : adc.w #!oam1_sizes : sta $08
	sep #$20
	sta $0e
	; x = !oam1_tile & $ff00 | y & $00ff
	lda.b #!oam1_tile>>8 : xba : tya : tax
	ldy $0a
	stz $04
	stz $07
; 00:    X-offset 8x8
; 01:    Y-offset
; 02:    X-offset 16x16
; 04:    0
; 05:    Sprite x-flip | level tile props
; 06-07: X-offset select ptr
; 08-09: size table ptr
; 0c:    negation for x-offset
; 0e:    first size table index
.loop
    lda $0001,y : bmi .end
	sta ($08)
	sta $06
	lda $0c : lsr
	lda $0004,y : eor $0c : adc ($06) : sta.b !oam1_ofsX,x
	lda $0005,y : clc : adc $01 : sta.b !oam1_ofsY,x
	rep #$21
	if !opt_katysHack == 0
		lda $0002,y : eor $04 : sta.b !oam1_tile,x
	else
		lda $0002,y : eor $04
		adc $01,s
		sta.b !oam1_tile,x
	endif
	txa : adc #$0004 : tax
	tya : adc #$0005 : tay
	sep #$20
	inc $08
	bra .loop
.end
	if !opt_katysHack
		pla
	endif
	sep #$31
	plx
	lda $08 : sbc $0e
	ldy #$ff
	jsl FinishOamWrite
	lda !dys_lastOam : sta !spr_oamIndex,x
	rts

%dys_ssr(SpawnSprite)
	jsl $02a9e4!F
	bmi .ret
	phx
	tyx
	lda $00 : sta !spr_custNum,x
	lda $01 : sta !spr_extraBit,x
	lda #$08 : sta !spr_status,x
	lda #$ff : sta !spr_loadStatIndex,x
	jsl $07f722!F
	jsl $07f7a4!F
	plx
.ret
	rtl

%dys_ssr(TranslateXY)
	jsl TranslateX
	jml TranslateY

END:
print "; Space used by dys SSRs: ", hex(END-START)
